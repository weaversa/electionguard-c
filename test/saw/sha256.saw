include "llvm.saw";
import "SHA256.cry";

sha256_bc <- llvm_load_module "obj/sha256.bc";

let {{
 rev_endian_32 v = join (reverse (split `{4} v))
}};
let ctx_struct (name : String) = do {
  state <- variable (llvm_array 8 (llvm_int 32)) (str_concat name ".state") FRESH;
  bitcount <- variable (llvm_array 2 (llvm_int 64)) (str_concat name ".bitcount") FRESH;
  buffer <- variable (llvm_array 128 (llvm_int 8)) (str_concat name ".buffer") FRESH;
  ctx <- struct [(crucible_struct [state.s]), bitcount.s, buffer.s];

  let (statet, bitcount, buffert) = (state.t, bitcount.t, buffer.t);
  // define a record so we can access the term like with .field
  let ctxt = {{ {state=statet, bitcount=bitcount, buffer=buffert} }};
  return {p=crucible_null, s=ctx.s, t=ctxt};
};

let ctx_new_ptr (name : String) = do {
  ctx <- ctx_struct name;
  ctxp <- pointer WRITE (llvm_struct "struct._SHA2_CTX") ;
  points_to ctxp ctx.s;  
  return {p=ctxp, s=ctx.s, t=ctx.t};
};

let ctx_assign_ptr (name: String) (ctxp : SetupValue) = do {
  ctx <- ctx_struct name;
  points_to ctxp ctx.s;  
  return {p=ctxp, s=ctx.s, t=ctx.t};
};



let sha256init_spec = do {
  ctx <- ctx_new_ptr "pre_init";

  execute [ctx.p];
  
  res <- ctx_assign_ptr "post_init" ctx.p;
  let post_ctx = res.t;
  

  postcond {{ (post_ctx.state == H0) /\
              (post_ctx.bitcount @ 0) == zero /\
              (post_ctx.buffer @ 0) == zero
	   }};
};

// define the T1 mixing function so we can use it as an uninterpreted function
let {{
  T1_f:  [32] -> [32] -> [32] -> [32] -> [32] -> [32] -> [32]
  T1_f e f g h k w = h + S1 e + Ch e f g  + k + w
}};

let t1_spec = do {
  e <- variable uint32_t "e" FRESH;
  f <- variable uint32_t "f" FRESH;
  g <- variable uint32_t "g" FRESH;
  h <- variable uint32_t "h" FRESH;
  k <- variable uint32_t "k" FRESH;
  w <- variable uint32_t "w" FRESH;

  execute [e.s, f.s, g.s, h.s, k.s, w.s];

  let (e_t, f_t, g_t, h_t, k_t, w_t) = (e.t, f.t, g.t, h.t, k.t, w.t);

  returns (from_cryptol {{ T1_f e_t f_t g_t h_t k_t w_t }});

};

T1_ov <- crucible_llvm_verify sha256_bc "T1_func" [] true (t1_spec) yices;

let ss0 = cryptol_ss ();

// rewrite SHA256Compress to use our T1_f function 
let tsub = {{
  \(e:[32]) f g h k w -> h + S1 e + Ch e f g  + k + w == T1_f e f g h k w
}};

t1_rewrite <- prove_print z3 (rewrite ss0 tsub);

let solver = do {
   unfolding ["SHA256Block", "SHA256Compress"];
   simplify (addsimp t1_rewrite ss0);
   unint_cvc4 ["T1_f"];
};

//void @SHA256Transform(%struct._SHA2_CTX* %0, i8* %1)
let sha256transform_spec = do {
  ctx <- ctx_new_ptr "pre_hash";
  data <- alloc CONST (llvm_array 64 (llvm_int 8)) "data" FRESH;

  execute [ctx.p, data.p];

  res <- ctx_assign_ptr "post_hash" ctx.p;

  let (pre_ctx, post_ctx, data_term) = (ctx.t, res.t, data.t);

  points_to data.p data.s;

  postcond {{ SHA256Block pre_ctx.state (split`{16} (join data_term)) == post_ctx.state}};
  postcond {{ pre_ctx.bitcount == post_ctx.bitcount}};
};

/* for when we are transforming the buffer in ctx */
let sha256transform_ctx_spec = do {
  ctx <- ctx_new_ptr "pre_hash";
  let datap = element ctx.p 2;

  execute [ctx.p, datap];

  res <- ctx_assign_ptr "post_hash" ctx.p;

  let (pre_ctx, post_ctx) = (ctx.t, res.t);

  postcond {{
    SHA256Block pre_ctx.state (split`{16} (join (pre_ctx.buffer @@ [0..63]))) ==
    post_ctx.state
  }};
  postcond {{ pre_ctx.bitcount == post_ctx.bitcount}};
};


let sha256update_spec = do {
  ctx <- ctx_new_ptr "preupdate_hash";

  let ctxt = ctx.t;

  precond {{ ctxt.bitcount @ 0 == zero }};

  data <- alloc CONST (llvm_array 64 (llvm_int 8)) "data" FRESH;
  len <- variable uint64_t "len" (STALE {{ 64 : [64] }});
  
  execute [ctx.p, data.p, len.s];

  res <- ctx_assign_ptr "postupdate_hash" ctx.p;
  let (pre_ctx, post_ctx, data_term) = (ctx.t, res.t, data.t);

  postcond {{ (SHA256Update pre_state data_term).h == post_ctx.state
              where pre_state = {h=pre_ctx.state,
	                         block=pre_ctx.buffer @@ [0..63],
				 n=0,
				 sz=zero}
	   }};
};

let test_sha256_spec (n : Int) = do {
  ctx <- ctx_new_ptr "context";
  //  digest <- alloc WRITE (llvm_array 32 (llvm_int 8)) "pre_digest" FRESH;
  //  digest <- pointer WRITE(llvm_array 32 (llvm_int 8));
  digest <- variable (llvm_array 8 (llvm_int 32)) "pre_digest" FRESH;
  digestp <- pointer WRITE (llvm_array 8 (llvm_int 32));
  points_to digestp digest.s;
  
  // when compiled for litte-endian
  //digest <- alloc WRITE (llvm_array 8 (llvm_int 32)) "pre_digest" FRESH;
  data <- alloc CONST (llvm_array n (llvm_int 8)) "data" FRESH;
  len <- variable uint64_t "len" (STALE {{ `n : [64] }});

  execute [ctx.p, digestp, data.p, len.s];

  // just test update
  /*
  res <- ctx_assign_ptr "postupdate_hash" ctx.p;
  let (pre_ctx, post_ctx, data_term) = (ctx.t, res.t, data.t);
  postcond {{ post_ctx.state == (SHA256Update SHA256Init data_term).h }};
  */

  // check the hash before it is converted to host order
  /*
  res <- ctx_assign_ptr "postupdate_hash" ctx.p;
  let (pre_ctx, post_ctx, data_term) = (ctx.t, res.t, data.t);
  postcond {{ join (map rev_endian_32 post_ctx.state) ==
              (SHA256Final (SHA256Update SHA256Init data_term)) }};
  */

  // test the full thing
  computed_digest <- variable (llvm_array 8 (llvm_int 32)) "post_digest" FRESH;
  points_to digestp computed_digest.s;

  let (computed_digest_t, data_t) = (computed_digest.t, data.t);
  // we need to reverse the words since SAW converts them to BE when reading 
  postcond {{ join (map rev_endian_32 computed_digest_t) ==
              (SHA256Final (SHA256Update SHA256Init data_t)) }};
};


/*
sha256transform_ov <- crucible_llvm_verify sha256_bc "SHA256Transform"
                      [T1_ov] true (sha256transform_spec)
		      solver;
sha256transform_ctx_ov <- crucible_llvm_verify sha256_bc "SHA256Transform"
                          [T1_ov] true (sha256transform_ctx_spec)
			  solver;
*/

sha256transform_ov <- crucible_llvm_unsafe_assume_spec sha256_bc
                      "SHA256Transform" sha256transform_spec;
sha256transform_ctx_ov <- crucible_llvm_unsafe_assume_spec sha256_bc
                          "SHA256Transform" sha256transform_ctx_spec;


crucible_llvm_verify sha256_bc "test_SHA256"
                     [sha256transform_ov, sha256transform_ctx_ov]
     		     true (test_sha256_spec 127)
//		     (unint_yices []);
		     (unint_yices ["SHA256Block"]);
//		     (quickcheck 10);

