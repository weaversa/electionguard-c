include "llvm.saw";

let {{
  from_mpz : {a, b} (fin a, fin b, a*64 >= b) => [a][64] -> [b]
  from_mpz List = drop (join List)
  
  to_mpz bv = groupBy`{64} (0#bv)
}};

mpz_bc <- llvm_load_module "obj/mpz.bc";

//%struct.__mpz_struct = type { i32, i32, i64* }
let mpz_t (rw : Term) (n : Int) (name : String) = do {
  //Here we assume the ElectionGuard-C code will never reference any
  //of these arguments, so we co-opt them for other purposes.

  //Here we let the first argument represent the number of bits.
  nBits <- variable uint32_t (str_concat name ".nBits") (STALE {{ `n : [32] }});

  //Here we let the second argument represent the number of words.
  nWords <- variable uint32_t (str_concat name ".nWords") (STALE {{ `(n /^ 64) : [32] }});

  //Here we let the third argument be a pointer to an allocated list n/^64 64-bit words.
  value <- alloc rw (llvm_array (eval_int {{ `(n /^ 64) : [32] }}) uint64_t) (str_concat name ".value") FRESH;

  v <- struct [nBits.s, nWords.s, value.p];

  vp <- pointer rw (struct_t "__mpz_struct");
  points_to vp v.s;

  let (nBitst,  nWordst,  valuet) =
      (nBits.t, nWords.t, value.t);
  let vt = {{ {nBits=nBitst, nWords=nWordst, value=valuet} }};

  return {p=vp, s=v.s, t=vt};
};

let mpz_t' (rw : Term) (n : Int) (name : String) (vp : SetupValue) = do {
  //Here we assume the ElectionGuard-C code will never reference any
  //of these arguments, so we co-opt them for other purposes.

  //Here we let the first argument represent the number of bits.
  nBits <- variable uint32_t (str_concat name ".nBits") (STALE {{ `n : [32] }});

  //Here we let the second argument represent the number of words.
  nWords <- variable uint32_t (str_concat name ".nWords") (STALE {{ `(n /^ 64) : [32] }});

  //Here we let the third argument be a pointer to an allocated list n/^64 64-bit words.
  value <- alloc rw (llvm_array (eval_int {{ `(n /^ 64) : [32] }}) uint64_t) (str_concat name ".value") FRESH;

  v <- struct [nBits.s, nWords.s, value.p];

  let (nBitst,  nWordst,  valuet) =
      (nBits.t, nWords.t, value.t);
  let vt = {{ {nBits=nBitst, nWords=nWordst, value=valuet} }};

  points_to vp v.s;

  return {p=vp, s=v.s, t=vt};
};


//void mpz_init (mpz_t x)
let mpz_init_spec (nBits : Int) = do {
  vp <- pointer UNINIT (struct_t "__mpz_struct");

  execute [vp];

  x' <- mpz_t' WRITE nBits "x'" vp;

  let xt' = x'.t;
  postcond {{ from_mpz`{b=nBits} xt'.value == (0 : [nBits]) }};
};

//mpz_init_ov <- crucible_llvm_verify mpz_bc "__gmpz_init" [] true (mpz_init_spec 256) z3;

//void mpz_import (mpz_t rop, size_t count, int order, size_t size, int endian, size_t nails, const void *op)
let mpz_import_spec (count : Int) (size : Int) = do {
  ropp <- pointer UNINIT (struct_t "__mpz_struct");
  op <- alloc CONST (llvm_array (eval_int {{ `(count * size) : [32] }}) uint8_t) "op" FRESH;

  execute [ropp, //!!! TODO fill these parameters in with fresh values later
           from_cryptol {{ `count : [32] }},
           from_cryptol {{ 1 : [32] }},
           from_cryptol {{ `size : [32] }},
           from_cryptol {{ 0 : [32] }},
           from_cryptol {{ 0 : [32] }},
           op.p];

  rop' <- mpz_t' WRITE (eval_int {{ `(count * size * 8) : [32] }}) "rop'" ropp;

  let (ropt', opt) = (rop'.t, op.t);
  postcond {{ from_mpz`{b=count*size*8} ropt'.value == (join (join [ reverse b | b <- groupBy`{8} opt])) }};
};

let glo_import_spec = do {
  global_init "glo";
  global_init "q_array";

  execute [];

  glo' <- mpz_t' WRITE 256 "glo'" (element (global "glo") 0);

  let glot = glo'.t;
  postcond {{ from_mpz`{b=256} glot.value == (join [1, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF43]) }};
};

let mpz_init_ov n = crucible_llvm_unsafe_assume_spec mpz_bc "__gmpz_init" (mpz_init_spec n);

mpz_init_256_ov <- mpz_init_ov 256;

let mpz_import_ov n m = crucible_llvm_unsafe_assume_spec mpz_bc "__gmpz_import" (mpz_import_spec n m);

mpz_import_4_8_ov <- mpz_import_ov 4 8;

print "First";
glo_import_ov <- crucible_llvm_verify mpz_bc "glo_import" [] true glo_import_spec z3;

print "Second";
glo_import_ov <- crucible_llvm_verify mpz_bc "glo_import" [mpz_init_256_ov] true glo_import_spec z3;

print "Third";
glo_import_ov <- crucible_llvm_verify mpz_bc "glo_import" [mpz_import_4_8_ov] true glo_import_spec z3;

print "Fourth";
glo_import_ov <- crucible_llvm_verify mpz_bc "glo_import" [mpz_init_256_ov, mpz_import_4_8_ov] true glo_import_spec z3;


//void mpz_set_ui (mpz_t rop, unsigned long int op)
let mpz_set_ui_spec (nBits : Int) = do {
  ropp <- pointer UNINIT (struct_t "__mpz_struct");
  op <- variable uint64_t "op" FRESH;

  execute [ropp, op.s];

  rop' <- mpz_t' WRITE nBits "rop'" ropp;

  let (ropt', opt) = (rop'.t, op.t);
  postcond {{ from_mpz`{b=nBits} ropt'.value == (0#opt : [nBits]) }};
};

/*
Function: void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod)
Function: void mpz_powm_ui (mpz_t rop, const mpz_t base, unsigned long int exp, const mpz_t mod)
Set rop to (base raised to exp) modulo mod.
*/
//void mpz_powm_ui (mpz_t rop, const mpz_t base, unsigned long int exp, const mpz_t mod)
let mpz_powm (nBits : Int) = do {
  ropp <- pointer UNINIT (struct_t "__mpz_struct");
  base <- mpz_t CONST nBits "base" FRESH;
  exp <- variable uint64_t "exp" FRESH;
  mod <- mpz_t CONST nBits "mod" FRESH;

  execute [ropp, base.p, exp.s, mod.p];

  rop' <- mpz_t' WRITE nBits "rop'" ropp;
  let (ropt', baset, expt, modt) = rop'.t, base.t, exp.t, mod.t);
  postcond {{ rop == drop ((base ^^ exp) % mod)
              where rop = from_mpz`{b=nBits} ropt'
	            base = 0 # (from_mpz`{b=nBits} baset) : [nBits*nBits]
    	            exp = 0 # expt : [nBits*nBits]
    	            mod = 0 # (from_mpz`{b=nBits} modt) : [nBits*nBits]
	   }};
};
